'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var jwtDecode = _interopDefault(require('jwt-decode'));
var coreHttp = require('@azure/core-http');
var crypto = require('crypto');
var coreAuth = require('@azure/core-auth');

// Copyright (c) Microsoft Corporation.
const parseToken = (token) => {
    const { exp } = jwtDecode(token);
    return {
        token,
        expiresOnTimestamp: exp * 1000
    };
};

// Copyright (c) Microsoft Corporation.
/**
 * StaticTokenCredential
 */
class StaticTokenCredential {
    constructor(token) {
        this.token = token;
    }
    getToken() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.token;
        });
    }
    dispose() {
        /* intentionally empty */
    }
}

// Copyright (c) Microsoft Corporation.
const expiredToken = { token: "", expiresOnTimestamp: -10 };
const minutesToMs = (minutes) => minutes * 1000 * 60;
const defaultRefreshingInterval = minutesToMs(10);
class AutoRefreshTokenCredential {
    constructor(refreshArgs) {
        this.refreshingIntervalInMs = defaultRefreshingInterval;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.disposed = false;
        const { tokenRefresher, token, refreshProactively } = refreshArgs;
        this.refresh = tokenRefresher;
        this.currentToken = token ? parseToken(token) : expiredToken;
        this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;
        if (this.refreshProactively) {
            this.scheduleRefresh();
        }
    }
    getToken(abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!this.isCurrentTokenExpiringSoon) {
                return this.currentToken;
            }
            const updatePromise = this.updateTokenAndReschedule(abortSignal);
            if (!this.isCurrentTokenValid) {
                yield updatePromise;
            }
            return this.currentToken;
        });
    }
    dispose() {
        this.disposed = true;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.currentToken = expiredToken;
        if (this.activeTimeout) {
            clearTimeout(this.activeTimeout);
        }
    }
    updateTokenAndReschedule(abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.activeTokenUpdating) {
                return this.activeTokenUpdating;
            }
            this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);
            try {
                yield this.activeTokenUpdating;
            }
            finally {
                this.activeTokenUpdating = null;
            }
        });
    }
    refreshTokenAndReschedule(abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this.currentToken = yield this.refreshToken(abortSignal);
            if (this.refreshProactively) {
                this.scheduleRefresh();
            }
        });
    }
    refreshToken(abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.activeTokenFetching) {
                    this.activeTokenFetching = this.refresh(abortSignal);
                }
                return parseToken(yield this.activeTokenFetching);
            }
            finally {
                this.activeTokenFetching = null;
            }
        });
    }
    scheduleRefresh() {
        if (this.disposed) {
            return;
        }
        if (this.activeTimeout) {
            clearTimeout(this.activeTimeout);
        }
        const timespanInMs = this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;
        this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);
    }
    get isCurrentTokenValid() {
        return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;
    }
    get isCurrentTokenExpiringSoon() {
        return (!this.currentToken ||
            Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The CommunicationTokenCredential implementation with support for proactive token refresh.
 */
class AzureCommunicationTokenCredential {
    constructor(tokenOrRefreshOptions) {
        this.disposed = false;
        if (typeof tokenOrRefreshOptions === "string") {
            this.tokenCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));
        }
        else {
            this.tokenCredential = new AutoRefreshTokenCredential(tokenOrRefreshOptions);
        }
    }
    /**
     * Gets an `AccessToken` for the user. Throws if already disposed.
     * @param abortSignal An implementation of `AbortSignalLike` to cancel the operation.
     */
    getToken(abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this.throwIfDisposed();
            const token = yield this.tokenCredential.getToken(abortSignal);
            this.throwIfDisposed();
            return token;
        });
    }
    /**
     * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.
     */
    dispose() {
        this.disposed = true;
        this.tokenCredential.dispose();
    }
    throwIfDisposed() {
        if (this.disposed) {
            throw new Error("User credential is disposed");
        }
    }
}

// Copyright (c) Microsoft Corporation.
const shaHash = (content) => tslib.__awaiter(void 0, void 0, void 0, function* () {
    return crypto.createHash("sha256")
        .update(content)
        .digest("base64");
});
const shaHMAC = (secret, content) => tslib.__awaiter(void 0, void 0, void 0, function* () {
    const decodedSecret = Buffer.from(secret, "base64");
    return crypto.createHmac("sha256", decodedSecret)
        .update(content)
        .digest("base64");
});

// Copyright (c) Microsoft Corporation.
/**
 * Creates an HTTP pipeline policy to authenticate a request
 * using an `KeyCredential`
 *
 * @param {KeyCredential} credential The key credential
 */
const createCommunicationAccessKeyCredentialPolicy = (credential) => {
    return {
        create: (nextpolicy, options) => {
            return new CommunicationAccessKeyCredentialPolicy(credential, nextpolicy, options);
        }
    };
};
/**
 * CommunicationAccessKeyCredentialPolicy provides a means of signing requests made through
 * the SmsClient.
 */
class CommunicationAccessKeyCredentialPolicy extends coreHttp.BaseRequestPolicy {
    /**
     * Initializes a new instance of the CommunicationAccessKeyCredential class
     * using a base64 encoded key.
     * @param accessKey The base64 encoded key to be used for signing.
     */
    constructor(accessKey, nextPolicy, options) {
        super(nextPolicy, options);
        this.accessKey = accessKey;
    }
    /**
     * Signs a request with the provided access key.
     *
     * @param {WebResource} webResource The WebResource to be signed.
     */
    signRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const verb = webResource.method.toUpperCase();
            const utcNow = new Date().toUTCString();
            const contentHash = yield shaHash(webResource.body || "");
            const dateHeader = coreHttp.isNode ? "date" : "x-ms-date";
            const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;
            const url = coreHttp.URLBuilder.parse(webResource.url);
            const query = url.getQuery();
            const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();
            const port = url.getPort();
            const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();
            const stringToSign = `${verb}\n${urlPathAndQuery}\n${utcNow};${hostAndPort};${contentHash}`;
            const signature = yield shaHMAC(this.accessKey.key, stringToSign);
            {
                webResource.headers.set("Host", hostAndPort || "");
            }
            webResource.headers.set(dateHeader, utcNow);
            webResource.headers.set("x-ms-content-sha256", contentHash);
            webResource.headers.set("Authorization", `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`);
            return webResource;
        });
    }
    /**
     * Signs the request and calls the next policy in the factory.
     *
     * @param {WebResourceLike} webResource
     */
    sendRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!webResource) {
                throw new Error("webResource cannot be null or undefined");
            }
            return this._nextPolicy.sendRequest(yield this.signRequest(webResource));
        });
    }
}

/**
 * Creates a pipeline policy to authenticate request based
 * on the credential passed in
 *
 * @param {KeyCredential | TokenCredential} credential The key credential
 */
const createCommunicationAuthPolicy = (credential) => {
    if (coreAuth.isTokenCredential(credential)) {
        return coreHttp.bearerTokenAuthenticationPolicy(credential, "https://communication.azure.com//.default");
    }
    else {
        return createCommunicationAccessKeyCredentialPolicy(credential);
    }
};

// Copyright (c) Microsoft Corporation.
// TODO: update when connection string format is finalized
const CONNECTION_STRING_REGEX = /endpoint=(.*);accesskey=(.*)/i;
const tryParseConnectionString = (s) => {
    const match = s.match(CONNECTION_STRING_REGEX);
    if ((match === null || match === void 0 ? void 0 : match[1]) && match[2]) {
        return { endpoint: match[1], credential: new coreAuth.AzureKeyCredential(match[2]) };
    }
    return undefined;
};
/**
 * Returns an EndpointCredential to easily access properties of the connection string
 *
 * @param {string} connectionString The connection string to parse
 * @returns {EndpointCredential} Object to access the endpoint and the credenials
 */
const parseConnectionString = (connectionString) => {
    const parsedConnectionString = tryParseConnectionString(connectionString);
    if (parsedConnectionString) {
        return parsedConnectionString;
    }
    else {
        throw new Error(`Invalid connection string ${connectionString}`);
    }
};

// Copyright (c) Microsoft Corporation.
const isValidEndpoint = (host) => {
    var _a;
    const url = coreHttp.URLBuilder.parse(host);
    return (!!((_a = url.getScheme()) === null || _a === void 0 ? void 0 : _a.match(/^http[s]?/)) &&
        url.getHost() !== undefined &&
        url.getHost() !== "" &&
        (url.getPath() === undefined || url.getPath() === "" || url.getPath() === "/"));
};
const assertValidEndpoint = (host) => {
    if (!isValidEndpoint(host)) {
        throw new Error(`Invalid endpoint url ${host}`);
    }
};
/**
 * Checks whether a value is a KeyCredential.
 *
 * @param {*} credential The credential being checked.
 */
const isKeyCredential = (credential) => {
    return credential && typeof credential.key === "string" && credential.getToken === undefined;
};
/**
 * Parses arguments passed to a communication client.
 *
 * @param {string} connectionStringOrUrl
 * @param {*} [credentialOrOptions]
 */
const parseClientArguments = (connectionStringOrUrl, credentialOrOptions) => {
    if (isKeyCredential(credentialOrOptions) || coreAuth.isTokenCredential(credentialOrOptions)) {
        assertValidEndpoint(connectionStringOrUrl);
        return { url: connectionStringOrUrl, credential: credentialOrOptions };
    }
    else {
        const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);
        assertValidEndpoint(host);
        return { url: host, credential };
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.
 *
 * @param identifier The assumed CommunicationUserIdentifier to be tested.
 */
const isCommunicationUserIdentifier = (identifier) => {
    return typeof identifier.communicationUserId === "string";
};
/**
 * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.
 *
 * @param identifier The assumed PhoneNumberIdentifier to be tested.
 */
const isPhoneNumberIdentifier = (identifier) => {
    return typeof identifier.phoneNumber === "string";
};
/**
 * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.
 *
 * @param identifier The assumed available to be tested.
 */
const isMicrosoftTeamsUserIdentifier = (identifier) => {
    return typeof identifier.microsoftTeamsUserId === "string";
};
/**
 * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.
 *
 * @param identifier The assumed CallingApplicationIdentifier to be tested.
 */
const isCallingApplicationIdentifier = (identifier) => {
    return typeof identifier.callingApplicationId === "string";
};
/**
 * Tests an Identifier to determine whether it implements UnknownIdentifier.
 *
 * @param identifier The assumed UnknownIdentifier to be tested.
 */
const isUnknownIdentifier = (identifier) => {
    return typeof identifier.id === "string";
};
/**
 * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.
 *
 * @param identifier The identifier whose kind is to be inferred.
 */
const getIdentifierKind = (identifier) => {
    if (isCommunicationUserIdentifier(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "communicationUser" });
    }
    if (isPhoneNumberIdentifier(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "phoneNumber" });
    }
    if (isCallingApplicationIdentifier(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "callingApplication" });
    }
    if (isMicrosoftTeamsUserIdentifier(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "microsoftTeamsUser" });
    }
    return Object.assign(Object.assign({}, identifier), { kind: "unknown" });
};

// Copyright (c) Microsoft Corporation.
const addIdIfExisting = (identifier, id) => {
    return id === undefined ? identifier : Object.assign(Object.assign({}, identifier), { id });
};
/**
 * @internal
 * Translates a CommunicationIdentifier to its serialized format for sending a request.
 * @param identifier The CommunicationIdentifier to be serialized.
 */
const _serializeCommunicationIdentifier = (identifier) => {
    var _a, _b;
    const identifierKind = getIdentifierKind(identifier);
    switch (identifierKind.kind) {
        case "communicationUser":
            return { kind: "communicationUser", id: identifierKind.communicationUserId };
        case "callingApplication":
            return { kind: "callingApplication", id: identifierKind.callingApplicationId };
        case "phoneNumber":
            return addIdIfExisting({ kind: "phoneNumber", phoneNumber: identifierKind.phoneNumber }, identifierKind.id);
        case "microsoftTeamsUser":
            return addIdIfExisting({
                kind: "microsoftTeamsUser",
                microsoftTeamsUserId: identifierKind.microsoftTeamsUserId,
                isAnonymous: (_a = identifierKind.isAnonymous) !== null && _a !== void 0 ? _a : false,
                cloud: (_b = identifierKind.cloud) !== null && _b !== void 0 ? _b : "public"
            }, identifierKind.id);
        case "unknown":
            return { kind: "unknown", id: identifierKind.id };
        default:
            throw new Error(`Can't serialize an identifier with kind ${identifierKind.kind}`);
    }
};
/**
 * @internal
 * Translates the serialized format of a communication identifier to CommunicationIdentifier.
 * @param serializedIdentifier The SerializedCommunicationIdentifier to be deserialized.
 */
const _deserializeCommunicationIdentifier = (serializedIdentifier) => {
    switch (serializedIdentifier.kind) {
        case "communicationUser":
            return {
                kind: "communicationUser",
                communicationUserId: assertNotNullOrUndefined(serializedIdentifier, "id"),
                id: assertNotNullOrUndefined(serializedIdentifier, "id")
            };
        case "callingApplication":
            return {
                kind: "callingApplication",
                callingApplicationId: assertNotNullOrUndefined(serializedIdentifier, "id"),
                id: assertNotNullOrUndefined(serializedIdentifier, "id")
            };
        case "phoneNumber":
            return {
                kind: "phoneNumber",
                phoneNumber: assertNotNullOrUndefined(serializedIdentifier, "phoneNumber"),
                id: assertNotNullOrUndefined(serializedIdentifier, "id")
            };
        case "microsoftTeamsUser":
            return {
                kind: "microsoftTeamsUser",
                microsoftTeamsUserId: assertNotNullOrUndefined(serializedIdentifier, "microsoftTeamsUserId"),
                isAnonymous: assertNotNullOrUndefined(serializedIdentifier, "isAnonymous"),
                cloud: assertNotNullOrUndefined(serializedIdentifier, "cloud"),
                id: assertNotNullOrUndefined(serializedIdentifier, "id")
            };
        case "unknown":
            return { kind: "unknown", id: assertNotNullOrUndefined(serializedIdentifier, "id") };
        default:
            return { kind: "unknown", id: assertNotNullOrUndefined(serializedIdentifier, "id") };
    }
};
const assertNotNullOrUndefined = (obj, prop) => {
    if (prop in obj) {
        return obj[prop];
    }
    throw new Error(`Property ${prop} is required for identifier of kind ${obj.kind}.`);
};

exports.AzureCommunicationTokenCredential = AzureCommunicationTokenCredential;
exports._deserializeCommunicationIdentifier = _deserializeCommunicationIdentifier;
exports._serializeCommunicationIdentifier = _serializeCommunicationIdentifier;
exports.createCommunicationAccessKeyCredentialPolicy = createCommunicationAccessKeyCredentialPolicy;
exports.createCommunicationAuthPolicy = createCommunicationAuthPolicy;
exports.getIdentifierKind = getIdentifierKind;
exports.isCallingApplicationIdentifier = isCallingApplicationIdentifier;
exports.isCommunicationUserIdentifier = isCommunicationUserIdentifier;
exports.isKeyCredential = isKeyCredential;
exports.isMicrosoftTeamsUserIdentifier = isMicrosoftTeamsUserIdentifier;
exports.isPhoneNumberIdentifier = isPhoneNumberIdentifier;
exports.isUnknownIdentifier = isUnknownIdentifier;
exports.parseClientArguments = parseClientArguments;
exports.parseConnectionString = parseConnectionString;
//# sourceMappingURL=index.js.map
