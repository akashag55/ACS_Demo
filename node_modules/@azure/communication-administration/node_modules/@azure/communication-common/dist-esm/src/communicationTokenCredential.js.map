{"version":3,"file":"communicationTokenCredential.js","sourceRoot":"","sources":["../../src/communicationTokenCredential.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAGlC,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAC3C,OAAO,EAAE,qBAAqB,EAAE,MAAM,yBAAyB,CAAC;AAChE,OAAO,EACL,0BAA0B,EAE3B,MAAM,8BAA8B,CAAC;AAmBtC;;GAEG;AACH,MAAM,OAAO,iCAAiC;IAe5C,YAAY,qBAAgE;QAbpE,aAAQ,GAAG,KAAK,CAAC;QAcvB,IAAI,OAAO,qBAAqB,KAAK,QAAQ,EAAE;YAC7C,IAAI,CAAC,eAAe,GAAG,IAAI,qBAAqB,CAAC,UAAU,CAAC,qBAAqB,CAAC,CAAC,CAAC;SACrF;aAAM;YACL,IAAI,CAAC,eAAe,GAAG,IAAI,0BAA0B,CAAC,qBAAqB,CAAC,CAAC;SAC9E;IACH,CAAC;IAED;;;OAGG;IACU,QAAQ,CAAC,WAA6B;;YACjD,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;YAC/D,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,OAAO,KAAK,CAAC;QACf,CAAC;KAAA;IAED;;OAEG;IACI,OAAO;QACZ,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC;IACjC,CAAC;IAEO,eAAe;QACrB,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;SAChD;IACH,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AccessToken } from \"@azure/core-http\";\nimport { parseToken } from \"./tokenParser\";\nimport { StaticTokenCredential } from \"./staticTokenCredential\";\nimport {\n  AutoRefreshTokenCredential,\n  CommunicationTokenRefreshOptions\n} from \"./autoRefreshTokenCredential\";\n\nexport type TokenCredential = Pick<AzureCommunicationTokenCredential, \"getToken\" | \"dispose\">;\n\n/**\n * The Azure Communication Services token credential.\n */\nexport interface CommunicationTokenCredential {\n  /**\n   * Gets an `AccessToken` for the user. Throws if already disposed.\n   * @param abortSignal An implementation of `AbortSignalLike` to cancel the operation.\n   */\n  getToken(abortSignal?: AbortSignalLike): Promise<AccessToken>;\n  /**\n   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.\n   */\n  dispose(): void;\n}\n\n/**\n * The CommunicationTokenCredential implementation with support for proactive token refresh.\n */\nexport class AzureCommunicationTokenCredential implements CommunicationTokenCredential {\n  private readonly tokenCredential: TokenCredential;\n  private disposed = false;\n\n  /**\n   * Creates an instance of CommunicationTokenCredential with a static token and no proactive refreshing.\n   * @param token A user access token issued by Communication Services.\n   */\n  constructor(token: string);\n  /**\n   * Creates an instance of CommunicationTokenCredential with a lambda to get a token and options\n   * to configure proactive refreshing.\n   * @param refreshOptions Options to configure refresh and opt-in to proactive refreshing.\n   */\n  constructor(refreshOptions: CommunicationTokenRefreshOptions);\n  constructor(tokenOrRefreshOptions: string | CommunicationTokenRefreshOptions) {\n    if (typeof tokenOrRefreshOptions === \"string\") {\n      this.tokenCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));\n    } else {\n      this.tokenCredential = new AutoRefreshTokenCredential(tokenOrRefreshOptions);\n    }\n  }\n\n  /**\n   * Gets an `AccessToken` for the user. Throws if already disposed.\n   * @param abortSignal An implementation of `AbortSignalLike` to cancel the operation.\n   */\n  public async getToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    this.throwIfDisposed();\n    const token = await this.tokenCredential.getToken(abortSignal);\n    this.throwIfDisposed();\n    return token;\n  }\n\n  /**\n   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.\n   */\n  public dispose(): void {\n    this.disposed = true;\n    this.tokenCredential.dispose();\n  }\n\n  private throwIfDisposed(): void {\n    if (this.disposed) {\n      throw new Error(\"User credential is disposed\");\n    }\n  }\n}\n"]}